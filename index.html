<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>MESA • WallStreetTV Crypto — BitPreço</title>
  <meta name="description" content="Painel estilo TV de Wall Street para BTC, ETH e BNB (pares BRL) usando API pública da BitPreço. Single-file • Vanilla JS" />
  <style>
    :root{
      --bg:#0A0C10;          /* fundo dark cinematográfico */
      --card:#11151C;        /* cards */
      --ink:#E8ECEF;         /* texto principal */
      --muted:#98A2B3;       /* texto secundário */
      --up:#00C853;          /* verde */
      --down:#FF3B30;        /* vermelho */
      --accent:#F5C451;      /* dourado sutil */
      --grid-gap: clamp(12px, 2.4vw, 24px);
    }
    *{box-sizing:border-box}
  html,body{height:100%; overflow-x:hidden}
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display:flex; flex-direction:column; min-height:100vh;
    }
  /* esconder barras de rolagem horizontais e minimizar verticais */
  html{scrollbar-width: none}         /* Firefox */
  html::-webkit-scrollbar{display:none} /* Chrome/Edge/Safari */
    .app{display:flex; flex-direction:column; min-height:100vh}
    header{
      display:flex; align-items:center; justify-content:space-between;
      padding: clamp(12px, 2vw, 18px) clamp(14px, 3vw, 28px);
      border-bottom: 1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0));
      position:sticky; top:0; z-index:2;
    }
    .brand{display:flex; gap:12px; align-items:center}
    .logo{
      width:34px; aspect-ratio:1; border-radius:8px;
      background: radial-gradient(120% 120% at 0% 0%, var(--accent), transparent),
                  linear-gradient(135deg, #1f2430 0%, #0d1117 70%);
      box-shadow: 0 10px 30px rgba(245,196,81,.2), inset 0 0 0 1px rgba(255,255,255,.05);
    }
    .brand h1{font-size: clamp(16px, 2.4vw, 22px); margin:0; letter-spacing:.5px}
    .sub{color:var(--muted); font-size: clamp(11px, 1.4vw, 13px)}
  .controls{display:flex; gap:10px; align-items:center}
  .version{padding:6px 10px; border-radius:999px; background:#0d121a; color:#cbd5e1; font-size:12px; font-weight:700; letter-spacing:.4px}
    button{all:unset; cursor:pointer; padding:10px 14px; border-radius:12px; background:#1a202c; color:#e6e6e6; font-weight:600}
    button:hover{background:#232b3a}
    .grid{
      display:grid; gap: var(--grid-gap);
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      padding: var(--grid-gap);
      width:100%; flex:1; align-content:start;
    }
    .tile{
      background: var(--card); border-radius:18px; padding:18px; position:relative;
      box-shadow: 0 8px 30px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.04);
      display:flex; flex-direction:column; gap:14px; min-height: 220px;
    }
    .row{display:flex; align-items:center; justify-content:space-between; gap:12px}
  /* permitir que a linha interna (preço + delta) encolha dentro do cabeçalho */
  .tile .row > .row{min-width:0}
    .id{display:flex; align-items:center; gap:10px}
    .ticker{font-size: clamp(18px, 4vw, 28px); font-weight:800; letter-spacing:1px}
    .pair{color:var(--muted); font-size: clamp(11px, 1.6vw, 12px)}
  .price{font-size: clamp(18px, 4.4vw, 40px); font-weight:900; line-height:1.1}
  /* preço ocupa todo espaço disponível e será reduzido via JS para caber */
  .row .price{min-width:0; flex:1 1 auto; white-space:nowrap}
    .delta{font-weight:700}
    .delta.up{color:var(--up)}
    .delta.down{color:var(--down)}
    .kpis{display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap:8px}
    .kpi{background:#0b0f16; border-radius:12px; padding:8px 10px}
    .kpi .label{color:var(--muted); font-size:12px}
    .kpi .value{font-weight:700; font-size:14px; margin-top:2px}
    .book{display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap:8px}
    .badge{font-size:11px; padding:4px 8px; border-radius:999px; background:#0d121a; color:var(--muted);}
    canvas.spark{width:100%; height:56px; border-radius:10px; background:linear-gradient(180deg,#0c1118,#0a0d12)}
    .trade{display:flex; gap:10px; align-items:center; font-size:13px; color:var(--muted)}
    .pill{padding:4px 8px; border-radius:8px; font-weight:700}
    .pill.buy{background: rgba(0,200,83,.12); color: var(--up)}
    .pill.sell{background: rgba(255,59,48,.12); color: var(--down)}
  footer{padding:8px 14px; color:var(--muted); display:flex; justify-content:space-between; align-items:center; border-top:1px solid rgba(255,255,255,.06)}
  .info{display:flex; flex-direction:column; gap:6px; align-items:flex-start}
  .wx-box{background:#0b0f16; color:#d1d7e0; border-radius:10px; padding:6px 10px; font-size:13px; line-height:1; box-shadow: inset 0 0 0 1px rgba(255,255,255,.05)}
  .wx-city{font-weight:700; margin-right:8px; color:#cbd5e1}
  .wx-temp{font-weight:800}
    .marquee{position:relative; white-space:nowrap; overflow:hidden}
    .marquee::before, .marquee::after{
      content:""; position:absolute; top:0; bottom:0; width:56px; z-index:1;
      pointer-events:none;
    }
    .marquee::before{
      left:0; background:linear-gradient(90deg, var(--bg), transparent);
    }
    .marquee::after{
      right:0; background:linear-gradient(-90deg, var(--bg), transparent);
    }
    .tape-track{
      position:relative; display:flex; gap:64px; align-items:center;
      will-change:transform; animation: tape-scroll var(--tape-speed, 40s) linear infinite;
    }
    .run{display:inline-flex; gap:24px; align-items:center; padding-left:24px}
    .tick{display:inline-flex; gap:10px; align-items:center; font-weight:700}
    .sym{color:#d1d7e0; font-size:13px; letter-spacing:.4px}
    .pri{font-size:14px}
    /* blink contínuo no ticker (up/down/flat) */
  .pri.blink{border-radius:6px; padding:2px 6px}
  .pri.blink.up{animation: blinkUp 1.2s ease-in-out infinite; color: var(--up)}
  .pri.blink.down{animation: blinkDown 1.2s ease-in-out infinite; color: var(--down)}
  .pri.blink.flat{animation: blinkFlat 1.8s ease-in-out infinite; color: #cbd5e1}
    @keyframes blinkUp{0%,100%{background:transparent}50%{background:rgba(0,200,83,.18)}}
    @keyframes blinkDown{0%,100%{background:transparent}50%{background:rgba(255,59,48,.18)}}
    @keyframes blinkFlat{0%,100%{background:transparent}50%{background:rgba(255,255,255,.08)}}
    @media (prefers-reduced-motion: reduce){
      .pri.blink.up,.pri.blink.down,.pri.blink.flat{animation:none}
    }
    .sig.up{color:var(--up)}
    .sig.down{color:var(--down)}
    .sep{opacity:.5; color:var(--muted)}
    @keyframes tape-scroll{100%{transform:translateX(-50%)}}
    @media (min-height: 800px){ canvas.spark{height:72px} }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>MESA • WallStreetTV Crypto</h1>
        <div class="sub">Fonte: API pública BitPreço (pares BRL) • Atualiza a cada <span id="intervalText">35s</span></div>
      </div>
    </div>
    <div class="controls">
  <div class="version" id="versionBadge">v0.0.5</div>
  <div class="sub">Última atualização: <strong id="lastUpdate">—</strong></div>
      <button id="fullscreenBtn" title="Ativar/Desativar tela cheia (F)">Tela cheia ⤢</button>
    </div>
  </header>

  <main class="grid" id="grid"></main>

  <footer>
    <div class="info">
      <div class="sub"><span id="brClock" title="Horário de Brasília">Brasília: --:--:--</span></div>
      <div class="wx-box" id="brWeather" aria-live="polite">—</div>
    </div>
    <div class="marquee" aria-hidden="true">
      <div class="tape-track" id="tapeTrack">
        <span class="run" id="tapeA"></span>
        <span class="run" id="tapeB"></span>
      </div>
    </div>
  </footer>
</div>

<script>
(() => {
  const APP_VERSION = 'v0.0.5';
  // ===== CONFIG ==============================================================
  const REFRESH_MS = 35_000; // 35 segundos
  const REFRESH_HIDDEN_MS = 90_000; // reduzir consumo quando aba estiver oculta
  const MAX_POINTS = 360;    // ~3.5h de histórico
  const TARGET_MAX_REQ_PER_MIN = 28; // margem de segurança sob 30/min
  const COINS = [
    { symbol: 'BTC', pair: 'btc-brl', label: 'BTC/BRL' },
    { symbol: 'ETH', pair: 'eth-brl', label: 'ETH/BRL' },
    { symbol: 'BNB', pair: 'bnb-brl', label: 'BNB/BRL' },
  { symbol: 'DASH', pair: 'dash-brl', label: 'DASH/BRL' },
  // adicionados
  { symbol: 'USDT', pair: 'usdt-brl', label: 'USDT/BRL' },
  { symbol: 'USDC', pair: 'usdc-brl', label: 'USDC/BRL' },
  { symbol: 'SOL',  pair: 'sol-brl',  label: 'SOL/BRL'  },
  { symbol: 'ADA',  pair: 'ada-brl',  label: 'ADA/BRL'  },
  { symbol: 'XRP',  pair: 'xrp-brl',  label: 'XRP/BRL'  },
  { symbol: 'DOGE', pair: 'doge-brl', label: 'DOGE/BRL' },
  ];
  const ENDPOINTS = {
    TICKERS_ALL: 'https://api.bitpreco.com/all-brl/ticker',
    TICKER:      (pair) => `https://api.bitpreco.com/${pair}/ticker`,
    ORDERBOOK:   (pair) => `https://api.bitpreco.com/${pair}/orderbook`,
    TRADES:      (pair) => `https://api.bitpreco.com/${pair}/trades`,
  };
  // Open-Meteo (sem API key) — temperatura atual por cidade
  const ENDPOINTS_WEATHER = {
    CURRENT: (lat, lon) => `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&timezone=America%2FSao_Paulo`,
  };
  // Binance (Spot) — públicos
  const ENDPOINTS_BINANCE = {
    PRICE:      (symbol) => `https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`,
    BOOK_TICKER:(symbol) => `https://api.binance.com/api/v3/ticker/bookTicker?symbol=${symbol}`,
  };
  const fmtBRL = new Intl.NumberFormat('pt-BR', { style:'currency', currency:'BRL' });
  const fmtNum = new Intl.NumberFormat('pt-BR', { maximumFractionDigits: 8 });
  const sleep = (ms)=> new Promise(r=> setTimeout(r, ms));

  function computeTradesEvery(baseMs){
    const N = COINS.length;
    const cpm = 60_000 / baseMs; // ciclos por minuto
    const baseline = cpm * (1 + N); // all-brl + orderbooks por ciclo
    const budget = TARGET_MAX_REQ_PER_MIN - baseline;
    if (budget <= 0) return 9999; // desabilita trades na prática
    const freq = Math.ceil((cpm * N) / budget); // ciclos entre fetch de trades
    return Math.max(1, Math.min(10, freq));
  }

  // ===== STATE ===============================================================
  const S = Object.fromEntries(COINS.map(c => [c.pair, {
    last:null, prev:null, high:null, low:null, vol:null, var:null,
    bid:null, ask:null, spread:null,
    trade:null, history:[], // preços recentes para sparkline
    lastAt:null, // timestamp do último update BitPreço
  alt:{ last:null, bid:null, ask:null, at:null }, // dados alternativos (Binance/sintético)
    _histAt:null, // controle de frequência de pontos no spark
  }]));

  // ===== DOM BUILD ===========================================================
  const grid = document.getElementById('grid');
  const versionBadge = document.getElementById('versionBadge');
  const tapeTrack = document.getElementById('tapeTrack');
  const tapeA = document.getElementById('tapeA');
  const tapeB = document.getElementById('tapeB');
  const lastUpdate = document.getElementById('lastUpdate');
  const intervalText = document.getElementById('intervalText');
  const brClock = document.getElementById('brClock');
  const brWeather = document.getElementById('brWeather');
  intervalText.textContent = Math.round(REFRESH_MS/1000)+"s";
  if(versionBadge) versionBadge.textContent = APP_VERSION;

  const tiles = {};
  // memória do último preço exibido na fita por par para disparar pulse sutil
  const TAPE_LAST = Object.create(null);
  // controle da fita para evitar 'pulos' ao re-renderizar
  let TAPE_LAST_HTML = '';
  let TAPE_START_TS = performance.now();
  // tempo e clima
  const WEATHER_CITIES = [
    { key:'BSB', name:'Brasília',       lat:-15.7939, lon:-47.8828 },
    { key:'SP',  name:'São Paulo',      lat:-23.5505, lon:-46.6333 },
    { key:'RIO', name:'Rio de Janeiro', lat:-22.9068, lon:-43.1729 },
    { key:'BH',  name:'Belo Horizonte', lat:-19.9167, lon:-43.9345 },
    { key:'SSA', name:'Salvador',       lat:-12.9777, lon:-38.5016 },
    { key:'FOR', name:'Fortaleza',      lat:-3.7319,  lon:-38.5267 },
    { key:'REC', name:'Recife',         lat:-8.0476,  lon:-34.8770 },
    { key:'CTA', name:'Curitiba',       lat:-25.4284, lon:-49.2733 },
    { key:'POA', name:'Porto Alegre',   lat:-30.0346, lon:-51.2177 },
    { key:'MAO', name:'Manaus',         lat:-3.1190,  lon:-60.0217 },
  ];
  const WEATHER_REFRESH_MS = 10*60*1000; // a cada 10 minutos
  const WEA = Object.fromEntries(WEATHER_CITIES.map(c=>[c.key,{temp:null, at:0}]));
  COINS.forEach(c => {
    const tile = document.createElement('section');
    tile.className = 'tile';
    tile.innerHTML = `
      <div class="row">
        <div class="id">
          <div class="ticker">${c.symbol}</div>
          <div class="pair">${c.label}</div>
        </div>
        <div class="row" style="gap:10px; align-items:flex-end">
          <div class="price" id="p-${c.pair}">—</div>
          <div class="delta" id="d-${c.pair}">—</div>
        </div>
      </div>
      <div class="kpis">
        <div class="kpi"><div class="label">Alta 24h</div><div class="value" id="hi-${c.pair}">—</div></div>
        <div class="kpi"><div class="label">Baixa 24h</div><div class="value" id="lo-${c.pair}">—</div></div>
        <div class="kpi"><div class="label">Volume 24h</div><div class="value" id="vo-${c.pair}">—</div></div>
      </div>
      <canvas class="spark" id="sp-${c.pair}" width="600" height="140" aria-label="mini gráfico da ${c.label}"></canvas>
      <div class="book">
        <div class="kpi"><div class="label">L1 BID</div><div class="value" id="bid-${c.pair}">—</div></div>
        <div class="kpi"><div class="label">L1 ASK</div><div class="value" id="ask-${c.pair}">—</div></div>
        <div class="kpi"><div class="label">Spread</div><div class="value" id="spu-${c.pair}">—</div></div>
      </div>
      <div class="trade" id="tr-${c.pair}">
        <span class="badge">Última negociação</span>
        <span class="pill" id="tt-${c.pair}">—</span>
        <span id="ta-${c.pair}">—</span>
        <span>•</span>
        <span id="tp-${c.pair}">—</span>
        <span>•</span>
        <span id="ts-${c.pair}">—</span>
      </div>
    `;
    grid.appendChild(tile);
    tiles[c.pair] = tile;
  });

  // ===== FETCHERS ============================================================
  async function getJSON(url){
    let attempt = 0;
    let delay = 500; // ms
    while(true){
      try{
        const res = await fetch(url, { cache:'no-store' });
        if(res.status === 429){
          // respeitar Retry-After se presente
          const ra = res.headers.get('Retry-After');
          const raMs = ra ? (Number(ra) * 1000) : delay;
          await sleep(raMs + Math.random()*250);
          attempt++; delay *= 2;
          if(attempt >= 3) throw new Error(`HTTP 429 (limite) @ ${url}`);
          continue;
        }
        if(!res.ok) throw new Error(`HTTP ${res.status} @ ${url}`);
        return await res.json();
      }catch(err){
        attempt++;
        if(attempt >= 3) throw err;
        await sleep(delay + Math.random()*200);
        delay *= 2;
      }
    }
  }

  async function fetchTickers(){
    try {
      const data = await getJSON(ENDPOINTS.TICKERS_ALL);
      for(const c of COINS){
        const k = c.pair; // ex.: "btc-brl"
        const keyUpperPair = k.toUpperCase(); // ex.: "BTC-BRL" (como vem no all-brl)
        const t = data[keyUpperPair] || data[k] || data[c.symbol] || data[c.symbol?.toUpperCase?.()] || data[c.symbol?.toLowerCase?.()];
        if(t){
          applyTicker(k, t);
        } else {
          // fallback: pegar individual
          const one = await getJSON(ENDPOINTS.TICKER(k));
          applyTicker(k, one);
        }
      }
    } catch(err){
      console.error('tickers/all falhou:', err);
      // fallback total
      await Promise.all(COINS.map(async c => {
        try{ applyTicker(c.pair, await getJSON(ENDPOINTS.TICKER(c.pair))); }catch(e){ console.error('ticker falhou', c.pair, e); }
      }));
    }
  }

  function applyTicker(pair, t){
    const st = S[pair];
    st.prev = st.last;
  const computedLast = Number(t.last ?? t.price ?? t.Last ?? t.LAST ?? NaN);
  st.last = (Number.isFinite(computedLast) && computedLast > 0) ? computedLast : NaN;
    st.high = Number(t.high ?? t.High ?? NaN);
    st.low  = Number(t.low  ?? t.Low  ?? NaN);
    st.vol  = Number(t.vol  ?? t.volume ?? NaN);
    st.var  = (t.var !== undefined) ? Number(t.var) : null; // var 24h conforme documentação BitPreço
    st.lastAt = Date.now();

  if(Number.isFinite(st.last) && st.last > 0){
      maybePushHistory(st, st.last);
    }
  }

  function maybePushHistory(st, price){
    const now = Date.now();
    const MIN_GAP = 10_000; // 10s entre pontos
    if(st._histAt && (now - st._histAt) < MIN_GAP) return;
    st._histAt = now;
    st.history.push(price);
    if(st.history.length > MAX_POINTS) st.history.shift();
  }

  // Para reduzir chamadas, buscamos TRADES em frequência dinâmica
  let cycleCount = 0;
  let FETCH_TRADES_EVERY = computeTradesEvery(REFRESH_MS);
  async function fetchOrderbookAndTrades(){
    const shouldFetchTrades = !document.hidden && ((cycleCount % FETCH_TRADES_EVERY) === 0);
    const BATCH = 3; // limitar bursts
    for(let i=0;i<COINS.length;i+=BATCH){
      const batch = COINS.slice(i, i+BATCH);
      await Promise.all(batch.map(async c => {
        const pair = c.pair;
        try{
          const ob = await getJSON(ENDPOINTS.ORDERBOOK(pair));
          const bestBid = ob.bids && ob.bids.length ? ob.bids[0] : null;
          const bestAsk = ob.asks && ob.asks.length ? ob.asks[0] : null;
          const bid = bestBid ? Number(bestBid.price ?? bestBid[1] ?? bestBid) : null;
          const ask = bestAsk ? Number(bestAsk.price ?? bestAsk[1] ?? bestAsk) : null;
          S[pair].bid = bid; S[pair].ask = ask; S[pair].spread = (bid && ask) ? (ask - bid) : null;
        }catch(e){ console.error('orderbook falhou', pair, e); }
        if(shouldFetchTrades){
          try{
            const tr = await getJSON(ENDPOINTS.TRADES(pair));
            // escolher a negociação mais recente
            const last = Array.isArray(tr) && tr.length ? tr.reduce((a,b)=> new Date(b.timestamp) > new Date(a.timestamp) ? b : a) : null;
            S[pair].trade = last || null;
          }catch(e){ console.error('trades falhou', pair, e); }
        }
      }));
      await sleep(200); // pequeno intervalo entre lotes
    }
  }

  // ===== BINANCE INTEGRAÇÃO (leve: preço + book ticker) =====================
  const BINANCE_SYMBOLS = Object.fromEntries(COINS.map(c=>{
    const s = c.pair.toUpperCase().replace(/-/g,''); // ex.: BTC-BRL => BTCBRL
    return [c.pair, s];
  }));

  // Símbolos auxiliares para fallback sintético (USDT cross)
  const BINANCE_AUX = { DASH_USDT: 'DASHUSDT', USDT_BRL: 'USDTBRL' };

  async function fetchBinanceLight(){
    const BATCH = 4;
    for(let i=0;i<COINS.length;i+=BATCH){
      const batch = COINS.slice(i, i+BATCH);
      await Promise.all(batch.map(async c => {
        const pair = c.pair;
        const sym = BINANCE_SYMBOLS[pair];
        if(!sym) return;
        try{
          // preço
          const tp = await getJSON(ENDPOINTS_BINANCE.PRICE(sym));
          const last = Number(tp?.price ?? NaN);
          if(Number.isFinite(last)){
            const st = S[pair];
            st.alt.last = last; st.alt.at = Date.now();
            maybePushHistory(st, last);
          }
  }catch(e){ /* símbolo pode não existir em BRL na Binance */ }
        try{
          // best bid/ask
          const bt = await getJSON(ENDPOINTS_BINANCE.BOOK_TICKER(sym));
          const bid = Number(bt?.bidPrice ?? NaN);
          const ask = Number(bt?.askPrice ?? NaN);
          const st = S[pair];
          st.alt.bid = Number.isFinite(bid) ? bid : st.alt.bid;
          st.alt.ask = Number.isFinite(ask) ? ask : st.alt.ask;
          if(Number.isFinite(st.alt.bid) && Number.isFinite(st.alt.ask)) st.alt.at = Date.now();
        }catch(e){ /* ignorar se indisponível */ }
        // fallback sintético DASH/BRL ≈ DASH/USDT * USDT/BRL
        if(pair === 'dash-brl' && (!Number.isFinite(S[pair].alt.last) || !sym || sym === 'DASHBRL')){
          try{
            const [pDashUsdt, pUsdtBrl] = await Promise.all([
              getJSON(ENDPOINTS_BINANCE.PRICE(BINANCE_AUX.DASH_USDT)),
              getJSON(ENDPOINTS_BINANCE.PRICE(BINANCE_AUX.USDT_BRL))
            ]);
            const a = Number(pDashUsdt?.price ?? NaN);
            const b = Number(pUsdtBrl?.price ?? NaN);
            const st = S[pair];
            if(Number.isFinite(a) && Number.isFinite(b)){
              const last = a * b;
              st.alt.last = last; st.alt.at = Date.now(); maybePushHistory(st, last);
            }
          }catch(e){ /* ignore */ }
        }
        // Fallback sintético completo para DASH/BRL usando USDT cross
        if(pair === 'dash-brl'){
          try{
            const [dashUsdtPrice, usdtBrlPrice, dashUsdtBook, usdtBrlBook] = await Promise.all([
              getJSON(ENDPOINTS_BINANCE.PRICE(BINANCE_AUX.DASH_USDT)),
              getJSON(ENDPOINTS_BINANCE.PRICE(BINANCE_AUX.USDT_BRL)),
              getJSON(ENDPOINTS_BINANCE.BOOK_TICKER(BINANCE_AUX.DASH_USDT)),
              getJSON(ENDPOINTS_BINANCE.BOOK_TICKER(BINANCE_AUX.USDT_BRL)),
            ]);
            const aLast = Number(dashUsdtPrice?.price ?? NaN);
            const bLast = Number(usdtBrlPrice?.price ?? NaN);
            const dashBid = Number(dashUsdtBook?.bidPrice ?? NaN);
            const dashAsk = Number(dashUsdtBook?.askPrice ?? NaN);
            const usdtBid = Number(usdtBrlBook?.bidPrice ?? NaN);
            const usdtAsk = Number(usdtBrlBook?.askPrice ?? NaN);
            const st = S[pair];
            if(Number.isFinite(aLast) && Number.isFinite(bLast)){
              const last = aLast * bLast;
              st.alt.last = last; st.alt.at = Date.now(); maybePushHistory(st, last);
            }
            if(Number.isFinite(dashBid) && Number.isFinite(usdtBid)) st.alt.bid = dashBid * usdtBid;
            if(Number.isFinite(dashAsk) && Number.isFinite(usdtAsk)) st.alt.ask = dashAsk * usdtAsk;
          }catch(e){ /* ignore */ }
        }
      }));
      await sleep(150);
    }
  }

  // ===== RENDER ==============================================================
  function render(){
    // fita/marquee estilizada
    const items = COINS.map(c => {
      const st = S[c.pair];
      const priceNum = choosePrice(st);
      const price = Number.isFinite(priceNum) ? fmtBRL.format(priceNum) : '—';
      const d = (st.prev && st.last) ? (st.last - st.prev) : 0;
      const cls = d>0 ? 'up' : d<0 ? 'down' : '';
      // decidir direção da piscada contínua
      let blinkCls = 'flat';
      const prevTape = TAPE_LAST[c.pair];
      if(Number.isFinite(priceNum) && Number.isFinite(prevTape)){
        if(priceNum > prevTape) blinkCls = 'up';
        else if(priceNum < prevTape) blinkCls = 'down';
        else blinkCls = 'flat';
      }
      if(Number.isFinite(priceNum)) TAPE_LAST[c.pair] = priceNum;
      return `<span class="tick"><span class="sym">${c.symbol}</span><span class="pri blink ${blinkCls}">${price}</span><span class="sig ${cls}">${d>0?'▲':d<0?'▼':'•'}</span></span>`;
    });
    const html = items.join('<span class="sep">·</span>');
    // Preenche duas execuções para loop contínuo, evitando updates desnecessários (que reiniciam a animação)
    if(tapeA && tapeB){
      if(html !== TAPE_LAST_HTML){
        tapeA.innerHTML = html; tapeB.innerHTML = html;
        TAPE_LAST_HTML = html;
        // manter fase da animação (defasagem negativa conforme tempo decorrido)
        tuneTickerSpeed(true);
      }
    }

    // tiles
    for(const c of COINS){
      const k = c.pair, st = S[k];
  const dispPrice = choosePrice(st);
  setPrice(`p-${k}`, dispPrice);
      // delta curto vs tick anterior
      let deltaStr = '—', cls = '';
      if(Number.isFinite(st.last) && Number.isFinite(st.prev)){
        const delta = st.last - st.prev;
        const perc = st.prev ? (delta/st.prev*100) : 0;
        deltaStr = `${delta>=0?'+':''}${perc.toFixed(2)}%`;
        cls = delta>0 ? 'up' : delta<0 ? 'down' : '';
      }
      setDelta(`d-${k}`, deltaStr, cls);

      setText(`hi-${k}`, Number.isFinite(st.high) ? fmtBRL.format(st.high) : '—');
      setText(`lo-${k}`, Number.isFinite(st.low)  ? fmtBRL.format(st.low)  : '—');
      setText(`vo-${k}`, Number.isFinite(st.vol)  ? fmtNum.format(st.vol)  : '—');

  const bidDisp = Number.isFinite(st.bid) ? st.bid : (Number.isFinite(st.alt.bid) ? st.alt.bid : null);
  const askDisp = Number.isFinite(st.ask) ? st.ask : (Number.isFinite(st.alt.ask) ? st.alt.ask : null);
  const sprDisp = (Number.isFinite(bidDisp) && Number.isFinite(askDisp)) ? (askDisp - bidDisp) : (Number.isFinite(st.spread) ? st.spread : null);
  setText(`bid-${k}`, Number.isFinite(bidDisp) ? fmtBRL.format(bidDisp) : '—');
  setText(`ask-${k}`, Number.isFinite(askDisp) ? fmtBRL.format(askDisp) : '—');
  setText(`spu-${k}`, Number.isFinite(sprDisp) ? fmtBRL.format(sprDisp) : '—');

      const tr = st.trade;
      const side = (tr?.type || tr?.TYPE || '').toString().toUpperCase();
      const sideClass = side === 'BUY' ? 'buy' : side === 'SELL' ? 'sell' : '';
      setPill(`tt-${k}`, side || '—', sideClass);
      setText(`ta-${k}`, tr?.amount != null ? `${fmtNum.format(Number(tr.amount))}` : '—');
      setText(`tp-${k}`, tr?.price  != null ? fmtBRL.format(Number(tr.price)) : '—');
      setText(`ts-${k}`, tr?.timestamp ? humanTime(tr.timestamp) : '—');

      drawSpark(`sp-${k}`, st.history);
    }
  }

  // Define preço com fallback de compactação e ajuste iterativo de fonte
  function setPrice(id, value){
    const el = document.getElementById(id); if(!el) return;
    const parent = el.parentElement; if(!parent){ el.textContent = '—'; return; }
    if(!Number.isFinite(value)){ el.textContent = '—'; return; }
    // reset estilo e tenta com formato normal
    el.style.fontSize = '';
    el.textContent = fmtBRL.format(value);
    fitToRow(el, parent);
  }

  // Ajusta a fonte para caber no espaço disponível da linha (considera o delta ao lado)
  function fitToRow(el, parent){
    // calcula largura disponível: largura do container menos largura do delta e gap
    const row = parent; // o parent é a .row interna
    const siblings = Array.from(row.children).filter(n=> n !== el);
    const deltaEl = siblings.find(n=> n.classList.contains('delta'));
    const gap = 10; // conforme inline style do container
    const deltaW = deltaEl ? deltaEl.getBoundingClientRect().width : 0;
    const maxW = Math.max(0, row.clientWidth - deltaW - gap - 2);

    // se já cabe, não faz nada
    if(el.scrollWidth <= maxW) return;

    // reduzir progressivamente até mínimo de 8px
    let style = getComputedStyle(el);
    let fs = parseFloat(style.fontSize) || 32;
    let guard = 0;
    while(el.scrollWidth > maxW && fs > 8 && guard < 20){
      fs = Math.max(8, Math.floor(fs * 0.9));
      el.style.fontSize = fs + 'px';
      guard++;
    }
  }

  function choosePrice(st){
    const now = Date.now();
    const freshMs = 2 * REFRESH_MS;
  if(Number.isFinite(st.last) && st.last > 0 && st.lastAt && (now - st.lastAt) < freshMs) return st.last;
    if(Number.isFinite(st.alt.last) && st.alt.at && (now - st.alt.at) < freshMs) return st.alt.last;
  return Number.isFinite(st.last) && st.last > 0 ? st.last : (Number.isFinite(st.alt.last) ? st.alt.last : NaN);
  }

  function setText(id, txt){ const el = document.getElementById(id); if(el) el.textContent = txt; }
  function setDelta(id, txt, cls){ const el = document.getElementById(id); if(!el) return; el.textContent=txt; el.className = `delta ${cls}`; }
  function setPill(id, txt, cls){ const el = document.getElementById(id); if(!el) return; el.textContent = txt; el.className = `pill ${cls}`; }

  function humanTime(ts){
    const t = new Date(ts);
    if(isNaN(+t)) return String(ts);
    const diff = (Date.now()-t.getTime())/1000; // s
    if(diff < 60) return `${Math.floor(diff)}s atrás`;
    if(diff < 3600) return `${Math.floor(diff/60)}min atrás`;
    const d = t.toLocaleTimeString('pt-BR',{hour:'2-digit',minute:'2-digit'});
    return d;
  }

  function drawSpark(id, series){
    const el = document.getElementById(id); if(!el) return;
    const ctx = el.getContext('2d');
    const w = el.width, h = el.height;
    // HiDPI fix
    const dpr = window.devicePixelRatio || 1;
    if(el._dpr !== dpr){ el._dpr = dpr; el.width = Math.floor(el.clientWidth*dpr); el.height = Math.floor(el.clientHeight*dpr); }
    const W = el.width, H = el.height;

    ctx.clearRect(0,0,W,H);
    // background grid-ish
    ctx.globalAlpha = .5; ctx.strokeStyle = 'rgba(255,255,255,.04)';
    const lines = 3; for(let i=1;i<=lines;i++){ const y = (H/(lines+1))*i; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    ctx.globalAlpha = 1;

    if(!series || series.length<2){ return; }
    const min = Math.min(...series), max = Math.max(...series);
    const pad = 6*dpr;
    const scaleX = (i)=> pad + (W-2*pad) * (i/(series.length-1));
    const scaleY = (v)=>{
      if(max===min) return H/2; // flat
      return H - pad - ( (v - min) / (max - min) ) * (H - 2*pad);
    };
    // line
    const last = series[series.length-1], prev = series[series.length-2];
    const up = last >= prev;
    ctx.lineWidth = 2*dpr;
    ctx.strokeStyle = up ? 'rgba(0,200,83,.95)' : 'rgba(255,59,48,.95)';
    ctx.beginPath();
    ctx.moveTo(scaleX(0), scaleY(series[0]));
    for(let i=1;i<series.length;i++) ctx.lineTo(scaleX(i), scaleY(series[i]));
    ctx.stroke();
    // gradient fill
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, up ? 'rgba(0,200,83,.20)' : 'rgba(255,59,48,.20)');
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.lineTo(W-pad, H-pad); ctx.lineTo(pad, H-pad); ctx.closePath(); ctx.fill();
  }

  // ===== LOOP ================================================================
  async function cycle(){
    await fetchTickers();
    await fetchOrderbookAndTrades();
    render();
    lastUpdate.textContent = new Date().toLocaleTimeString('pt-BR', {hour:'2-digit', minute:'2-digit', second:'2-digit'});
  cycleCount++;
  // ajustar velocidade da fita após render
  tuneTickerSpeed();
  }

  // ===== SCHEDULER: evita sobreposição e ajusta conforme visibilidade =======
  let _cycleTimer = null;
  let _isRunning = false;
  function nextDelay(){ return document.hidden ? REFRESH_HIDDEN_MS : REFRESH_MS; }
  function scheduleNext(ms){ if(_cycleTimer) clearTimeout(_cycleTimer); _cycleTimer = setTimeout(runCycle, ms); }
  async function runCycle(){
    if(_isRunning){ scheduleNext(250); return; }
    _isRunning = true;
    try{ await cycle(); }
    catch(e){ console.error('cycle erro:', e); }
    finally{
      try{
        // alterna atualizações leves da Binance entre ciclos
        if((cycleCount % 2) === 1){ await fetchBinanceLight(); render(); }
      }catch(e){ console.error('binance erro:', e); }
      _isRunning = false; scheduleNext(nextDelay());
    }
  }
  // kick
  runCycle();
  // inicializa fase da animação da fita
  requestAnimationFrame(()=>{
    TAPE_START_TS = performance.now();
    tuneTickerSpeed(true);
  });
  // relógio de Brasília atualizado a cada segundo
  const brFmt = new Intl.DateTimeFormat('pt-BR', { timeZone:'America/Sao_Paulo', hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit' });
  function tickClock(){ if(brClock) brClock.textContent = `Brasília: ${brFmt.format(new Date())}`; }
  tickClock();
  setInterval(tickClock, 1000);

  // clima: busca inicial e atualizações periódicas leves
  async function fetchWeatherAll(){
    const BATCH = 3;
    for(let i=0;i<WEATHER_CITIES.length;i+=BATCH){
      const batch = WEATHER_CITIES.slice(i, i+BATCH);
      await Promise.all(batch.map(async c => {
        try{
          const data = await getJSON(ENDPOINTS_WEATHER.CURRENT(c.lat, c.lon));
          const temp = Number(data?.current_weather?.temperature);
          if(Number.isFinite(temp)){
            WEA[c.key].temp = temp; WEA[c.key].at = Date.now();
          }
        }catch(e){ /* ignora falhas individuais */ }
      }));
      await sleep(200);
    }
    renderWeatherBox(); // reflete temperatura atual na caixinha
  }
  fetchWeatherAll();
  setInterval(fetchWeatherAll, WEATHER_REFRESH_MS);

  // Exibir uma capital por vez na caixinha, trocando a cada 1 minuto
  let WEATHER_IDX = 0;
  const WEATHER_ROTATE_MS = 60_000;
  function renderWeatherBox(){
    if(!brWeather) return;
    const city = WEATHER_CITIES[WEATHER_IDX % WEATHER_CITIES.length];
    const rec = WEA[city.key];
    const t = Number(rec?.temp);
    const tStr = Number.isFinite(t) ? `${Math.round(t)}°C` : '—°C';
    brWeather.innerHTML = `<span class="wx-city">${city.name}</span><span class="wx-temp">${tStr}</span>`;
  }
  function rotateCity(){ WEATHER_IDX = (WEATHER_IDX + 1) % WEATHER_CITIES.length; renderWeatherBox(); }
  renderWeatherBox();
  setInterval(rotateCity, WEATHER_ROTATE_MS);
  document.addEventListener('visibilitychange', () => {
    // Recalcular frequência de trades quando voltar a ficar visível
    if(!document.hidden){ FETCH_TRADES_EVERY = computeTradesEvery(REFRESH_MS); }
    scheduleNext(250);
  });

  // ===== TICKER SPEED ADAPTATION ===========================================
  function tuneTickerSpeed(forcePhase=false){
    if(!tapeTrack || !tapeA) return;
    const total = tapeA.scrollWidth; // one run
    // target ~110px/s for readability
    const pxPerSec = 110;
    const seconds = Math.max(20, Math.min(90, total / pxPerSec));
    const prev = getComputedStyle(tapeTrack).getPropertyValue('--tape-speed').trim();
    tapeTrack.style.setProperty('--tape-speed', seconds + 's');
    // preservar a fase da animação ao mudar duração ou conteúdo
    if(forcePhase || (prev !== (seconds + 's'))){
      const elapsed = (performance.now() - TAPE_START_TS) / 1000;
      const phase = (elapsed % seconds).toFixed(3);
      tapeTrack.style.animationDelay = `-${phase}s`;
    }
  }
  const roTicker = new ResizeObserver(()=> tuneTickerSpeed());
  if(tapeTrack) roTicker.observe(tapeTrack);

  // ===== FULLSCREEN ==========================================================
  const fsBtn = document.getElementById('fullscreenBtn');
  fsBtn.addEventListener('click', toggleFS);
  document.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='f') toggleFS(); });
  function toggleFS(){
    const el = document.documentElement;
    if(!document.fullscreenElement){
      (el.requestFullscreen && el.requestFullscreen()) ||
      (el.webkitRequestFullscreen && el.webkitRequestFullscreen());
    } else {
      (document.exitFullscreen && document.exitFullscreen()) ||
      (document.webkitExitFullscreen && document.webkitExitFullscreen());
    }
  }

  // ===== RESIZE SPARKLINES ON LAYOUT CHANGES ================================
  const ro = new ResizeObserver(()=> render());
  ro.observe(grid);
})();
</script>

<!--
Referências de API (BitPreço):
- Ticker (moeda):    https://api.bitpreco.com/btc-brl/ticker
- Ticker (todas):    https://api.bitpreco.com/all-brl/ticker
- Orderbook (moeda): https://api.bitpreco.com/btc-brl/orderbook
- Trades (moeda):    https://api.bitpreco.com/btc-brl/trades

Limite de taxa (doc BitPreço): até 30 acessos/min somando API pública e de negociações.

Observações:
- Se algum par não existir (ex.: BNB-BRL indisponível), o card exibirá "—".
- Este arquivo é "single-file" (HTML, CSS e JS inline). Hospede em qualquer servidor estático
  (GitHub Pages, DigitalOcean, etc.)
- Para alterar moedas/intervalo, ajuste o array COINS e REFRESH_MS no topo do script.
-->
</body>
</html>
