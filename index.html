<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>MESA • WallStreetTV Crypto — BitPreço</title>
  <meta name="description" content="Painel estilo TV de Wall Street para BTC, ETH e BNB (pares BRL) usando API pública da BitPreço. Single-file • Vanilla JS" />
  <style>
    :root{
      --bg:#0A0C10;          /* fundo dark cinematográfico */
      --card:#11151C;        /* cards */
      --ink:#E8ECEF;         /* texto principal */
      --muted:#98A2B3;       /* texto secundário */
      --up:#00C853;          /* verde */
      --down:#FF3B30;        /* vermelho */
      --accent:#F5C451;      /* dourado sutil */
      --grid-gap: clamp(12px, 2.4vw, 24px);
    }
    *{box-sizing:border-box}
  html,body{height:100%; overflow-x:hidden}
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display:flex; flex-direction:column; min-height:100vh;
    }
  /* esconder barras de rolagem horizontais e minimizar verticais */
  html{scrollbar-width: none}         /* Firefox */
  html::-webkit-scrollbar{display:none} /* Chrome/Edge/Safari */
    .app{display:flex; flex-direction:column; min-height:100vh}
    header{
      display:flex; align-items:center; justify-content:space-between;
      padding: clamp(12px, 2vw, 18px) clamp(14px, 3vw, 28px);
      border-bottom: 1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0));
      position:sticky; top:0; z-index:2;
    }
    .brand{display:flex; gap:12px; align-items:center}
    .logo{
      width:34px; aspect-ratio:1; border-radius:8px;
      background: radial-gradient(120% 120% at 0% 0%, var(--accent), transparent),
                  linear-gradient(135deg, #1f2430 0%, #0d1117 70%);
      box-shadow: 0 10px 30px rgba(245,196,81,.2), inset 0 0 0 1px rgba(255,255,255,.05);
    }
    .brand h1{font-size: clamp(16px, 2.4vw, 22px); margin:0; letter-spacing:.5px}
    .sub{color:var(--muted); font-size: clamp(11px, 1.4vw, 13px)}
    .controls{display:flex; gap:10px; align-items:center}
    button{all:unset; cursor:pointer; padding:10px 14px; border-radius:12px; background:#1a202c; color:#e6e6e6; font-weight:600}
    button:hover{background:#232b3a}
    .grid{
      display:grid; gap: var(--grid-gap);
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      padding: var(--grid-gap);
      width:100%; flex:1; align-content:start;
    }
    .tile{
      background: var(--card); border-radius:18px; padding:18px; position:relative;
      box-shadow: 0 8px 30px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.04);
      display:flex; flex-direction:column; gap:14px; min-height: 220px;
    }
    .row{display:flex; align-items:center; justify-content:space-between; gap:12px}
  /* permitir que a linha interna (preço + delta) encolha dentro do cabeçalho */
  .tile .row > .row{min-width:0}
    .id{display:flex; align-items:center; gap:10px}
    .ticker{font-size: clamp(18px, 4vw, 28px); font-weight:800; letter-spacing:1px}
    .pair{color:var(--muted); font-size: clamp(11px, 1.6vw, 12px)}
  .price{font-size: clamp(18px, 4.4vw, 40px); font-weight:900; line-height:1.1}
  /* prevenir overflow do preço em linhas flex */
  .row .price{min-width:0; flex:1 1 auto; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .delta{font-weight:700}
    .delta.up{color:var(--up)}
    .delta.down{color:var(--down)}
    .kpis{display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap:8px}
    .kpi{background:#0b0f16; border-radius:12px; padding:8px 10px}
    .kpi .label{color:var(--muted); font-size:12px}
    .kpi .value{font-weight:700; font-size:14px; margin-top:2px}
    .book{display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap:8px}
    .badge{font-size:11px; padding:4px 8px; border-radius:999px; background:#0d121a; color:var(--muted);}
    canvas.spark{width:100%; height:56px; border-radius:10px; background:linear-gradient(180deg,#0c1118,#0a0d12)}
    .trade{display:flex; gap:10px; align-items:center; font-size:13px; color:var(--muted)}
    .pill{padding:4px 8px; border-radius:8px; font-weight:700}
    .pill.buy{background: rgba(0,200,83,.12); color: var(--up)}
    .pill.sell{background: rgba(255,59,48,.12); color: var(--down)}
    footer{padding:8px 14px; color:var(--muted); display:flex; justify-content:space-between; align-items:center; border-top:1px solid rgba(255,255,255,.06)}
    .marquee{white-space:nowrap; overflow:hidden}
    .marquee span{display:inline-block; padding-left:100%; animation: scroll 40s linear infinite}
    @keyframes scroll{100%{transform:translateX(-100%)}}
    @media (min-height: 800px){ canvas.spark{height:72px} }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>MESA • WallStreetTV Crypto</h1>
        <div class="sub">Fonte: API pública BitPreço (pares BRL) • Atualiza a cada <span id="intervalText">35s</span></div>
      </div>
    </div>
    <div class="controls">
      <div class="sub">Última atualização: <strong id="lastUpdate">—</strong></div>
      <button id="fullscreenBtn" title="Ativar/Desativar tela cheia (F)">Tela cheia ⤢</button>
    </div>
  </header>

  <main class="grid" id="grid"></main>

  <footer>
    <div class="sub">Uso educativo / visual. Não é recomendação de investimento.</div>
    <div class="marquee" aria-hidden="true"><span id="tape"></span></div>
  </footer>
</div>

<script>
(() => {
  // ===== CONFIG ==============================================================
  const REFRESH_MS = 35_000; // 35 segundos
  const REFRESH_HIDDEN_MS = 90_000; // reduzir consumo quando aba estiver oculta
  const MAX_POINTS = 360;    // ~3.5h de histórico
  const TARGET_MAX_REQ_PER_MIN = 28; // margem de segurança sob 30/min
  const COINS = [
    { symbol: 'BTC', pair: 'btc-brl', label: 'BTC/BRL' },
    { symbol: 'ETH', pair: 'eth-brl', label: 'ETH/BRL' },
    { symbol: 'BNB', pair: 'bnb-brl', label: 'BNB/BRL' },
  // adicionados
  { symbol: 'USDT', pair: 'usdt-brl', label: 'USDT/BRL' },
  { symbol: 'USDC', pair: 'usdc-brl', label: 'USDC/BRL' },
  { symbol: 'SOL',  pair: 'sol-brl',  label: 'SOL/BRL'  },
  { symbol: 'ADA',  pair: 'ada-brl',  label: 'ADA/BRL'  },
  { symbol: 'XRP',  pair: 'xrp-brl',  label: 'XRP/BRL'  },
  { symbol: 'DOGE', pair: 'doge-brl', label: 'DOGE/BRL' },
  ];
  const ENDPOINTS = {
    TICKERS_ALL: 'https://api.bitpreco.com/all-brl/ticker',
    TICKER:      (pair) => `https://api.bitpreco.com/${pair}/ticker`,
    ORDERBOOK:   (pair) => `https://api.bitpreco.com/${pair}/orderbook`,
    TRADES:      (pair) => `https://api.bitpreco.com/${pair}/trades`,
  };
  // Binance (Spot) — públicos
  const ENDPOINTS_BINANCE = {
    PRICE:      (symbol) => `https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`,
    BOOK_TICKER:(symbol) => `https://api.binance.com/api/v3/ticker/bookTicker?symbol=${symbol}`,
  };
  const fmtBRL = new Intl.NumberFormat('pt-BR', { style:'currency', currency:'BRL' });
  const fmtNum = new Intl.NumberFormat('pt-BR', { maximumFractionDigits: 8 });
  const sleep = (ms)=> new Promise(r=> setTimeout(r, ms));

  function computeTradesEvery(baseMs){
    const N = COINS.length;
    const cpm = 60_000 / baseMs; // ciclos por minuto
    const baseline = cpm * (1 + N); // all-brl + orderbooks por ciclo
    const budget = TARGET_MAX_REQ_PER_MIN - baseline;
    if (budget <= 0) return 9999; // desabilita trades na prática
    const freq = Math.ceil((cpm * N) / budget); // ciclos entre fetch de trades
    return Math.max(1, Math.min(10, freq));
  }

  // ===== STATE ===============================================================
  const S = Object.fromEntries(COINS.map(c => [c.pair, {
    last:null, prev:null, high:null, low:null, vol:null, var:null,
    bid:null, ask:null, spread:null,
    trade:null, history:[], // preços recentes para sparkline
    lastAt:null, // timestamp do último update BitPreço
    alt:{ last:null, bid:null, ask:null, at:null }, // dados alternativos (Binance)
    _histAt:null, // controle de frequência de pontos no spark
  }]));

  // ===== DOM BUILD ===========================================================
  const grid = document.getElementById('grid');
  const tape = document.getElementById('tape');
  const lastUpdate = document.getElementById('lastUpdate');
  const intervalText = document.getElementById('intervalText');
  intervalText.textContent = Math.round(REFRESH_MS/1000)+"s";

  const tiles = {};
  COINS.forEach(c => {
    const tile = document.createElement('section');
    tile.className = 'tile';
    tile.innerHTML = `
      <div class="row">
        <div class="id">
          <div class="ticker">${c.symbol}</div>
          <div class="pair">${c.label}</div>
        </div>
        <div class="row" style="gap:10px; align-items:flex-end">
          <div class="price" id="p-${c.pair}">—</div>
          <div class="delta" id="d-${c.pair}">—</div>
        </div>
      </div>
      <div class="kpis">
        <div class="kpi"><div class="label">Alta 24h</div><div class="value" id="hi-${c.pair}">—</div></div>
        <div class="kpi"><div class="label">Baixa 24h</div><div class="value" id="lo-${c.pair}">—</div></div>
        <div class="kpi"><div class="label">Volume 24h</div><div class="value" id="vo-${c.pair}">—</div></div>
      </div>
      <canvas class="spark" id="sp-${c.pair}" width="600" height="140" aria-label="mini gráfico da ${c.label}"></canvas>
      <div class="book">
        <div class="kpi"><div class="label">L1 BID</div><div class="value" id="bid-${c.pair}">—</div></div>
        <div class="kpi"><div class="label">L1 ASK</div><div class="value" id="ask-${c.pair}">—</div></div>
        <div class="kpi"><div class="label">Spread</div><div class="value" id="spu-${c.pair}">—</div></div>
      </div>
      <div class="trade" id="tr-${c.pair}">
        <span class="badge">Última negociação</span>
        <span class="pill" id="tt-${c.pair}">—</span>
        <span id="ta-${c.pair}">—</span>
        <span>•</span>
        <span id="tp-${c.pair}">—</span>
        <span>•</span>
        <span id="ts-${c.pair}">—</span>
      </div>
    `;
    grid.appendChild(tile);
    tiles[c.pair] = tile;
  });

  // ===== FETCHERS ============================================================
  async function getJSON(url){
    let attempt = 0;
    let delay = 500; // ms
    while(true){
      try{
        const res = await fetch(url, { cache:'no-store' });
        if(res.status === 429){
          // respeitar Retry-After se presente
          const ra = res.headers.get('Retry-After');
          const raMs = ra ? (Number(ra) * 1000) : delay;
          await sleep(raMs + Math.random()*250);
          attempt++; delay *= 2;
          if(attempt >= 3) throw new Error(`HTTP 429 (limite) @ ${url}`);
          continue;
        }
        if(!res.ok) throw new Error(`HTTP ${res.status} @ ${url}`);
        return await res.json();
      }catch(err){
        attempt++;
        if(attempt >= 3) throw err;
        await sleep(delay + Math.random()*200);
        delay *= 2;
      }
    }
  }

  async function fetchTickers(){
    try {
      const data = await getJSON(ENDPOINTS.TICKERS_ALL);
      for(const c of COINS){
        const k = c.pair; // ex.: "btc-brl"
        const keyUpperPair = k.toUpperCase(); // ex.: "BTC-BRL" (como vem no all-brl)
        const t = data[keyUpperPair] || data[k] || data[c.symbol] || data[c.symbol?.toUpperCase?.()] || data[c.symbol?.toLowerCase?.()];
        if(t){
          applyTicker(k, t);
        } else {
          // fallback: pegar individual
          const one = await getJSON(ENDPOINTS.TICKER(k));
          applyTicker(k, one);
        }
      }
    } catch(err){
      console.error('tickers/all falhou:', err);
      // fallback total
      await Promise.all(COINS.map(async c => {
        try{ applyTicker(c.pair, await getJSON(ENDPOINTS.TICKER(c.pair))); }catch(e){ console.error('ticker falhou', c.pair, e); }
      }));
    }
  }

  function applyTicker(pair, t){
    const st = S[pair];
    st.prev = st.last;
    st.last = Number(t.last ?? t.price ?? t.Last ?? t.LAST ?? NaN);
    st.high = Number(t.high ?? t.High ?? NaN);
    st.low  = Number(t.low  ?? t.Low  ?? NaN);
    st.vol  = Number(t.vol  ?? t.volume ?? NaN);
    st.var  = (t.var !== undefined) ? Number(t.var) : null; // var 24h conforme documentação BitPreço
    st.lastAt = Date.now();

    if(Number.isFinite(st.last)){
      maybePushHistory(st, st.last);
    }
  }

  function maybePushHistory(st, price){
    const now = Date.now();
    const MIN_GAP = 10_000; // 10s entre pontos
    if(st._histAt && (now - st._histAt) < MIN_GAP) return;
    st._histAt = now;
    st.history.push(price);
    if(st.history.length > MAX_POINTS) st.history.shift();
  }

  // Para reduzir chamadas, buscamos TRADES em frequência dinâmica
  let cycleCount = 0;
  let FETCH_TRADES_EVERY = computeTradesEvery(REFRESH_MS);
  async function fetchOrderbookAndTrades(){
    const shouldFetchTrades = !document.hidden && ((cycleCount % FETCH_TRADES_EVERY) === 0);
    const BATCH = 3; // limitar bursts
    for(let i=0;i<COINS.length;i+=BATCH){
      const batch = COINS.slice(i, i+BATCH);
      await Promise.all(batch.map(async c => {
        const pair = c.pair;
        try{
          const ob = await getJSON(ENDPOINTS.ORDERBOOK(pair));
          const bestBid = ob.bids && ob.bids.length ? ob.bids[0] : null;
          const bestAsk = ob.asks && ob.asks.length ? ob.asks[0] : null;
          const bid = bestBid ? Number(bestBid.price ?? bestBid[1] ?? bestBid) : null;
          const ask = bestAsk ? Number(bestAsk.price ?? bestAsk[1] ?? bestAsk) : null;
          S[pair].bid = bid; S[pair].ask = ask; S[pair].spread = (bid && ask) ? (ask - bid) : null;
        }catch(e){ console.error('orderbook falhou', pair, e); }
        if(shouldFetchTrades){
          try{
            const tr = await getJSON(ENDPOINTS.TRADES(pair));
            // escolher a negociação mais recente
            const last = Array.isArray(tr) && tr.length ? tr.reduce((a,b)=> new Date(b.timestamp) > new Date(a.timestamp) ? b : a) : null;
            S[pair].trade = last || null;
          }catch(e){ console.error('trades falhou', pair, e); }
        }
      }));
      await sleep(200); // pequeno intervalo entre lotes
    }
  }

  // ===== BINANCE INTEGRAÇÃO (leve: preço + book ticker) =====================
  const BINANCE_SYMBOLS = Object.fromEntries(COINS.map(c=>{
    const s = c.pair.toUpperCase().replace(/-/g,''); // ex.: BTC-BRL => BTCBRL
    return [c.pair, s];
  }));

  async function fetchBinanceLight(){
    const BATCH = 4;
    for(let i=0;i<COINS.length;i+=BATCH){
      const batch = COINS.slice(i, i+BATCH);
      await Promise.all(batch.map(async c => {
        const pair = c.pair;
        const sym = BINANCE_SYMBOLS[pair];
        if(!sym) return;
        try{
          // preço
          const tp = await getJSON(ENDPOINTS_BINANCE.PRICE(sym));
          const last = Number(tp?.price ?? NaN);
          if(Number.isFinite(last)){
            const st = S[pair];
            st.alt.last = last; st.alt.at = Date.now();
            maybePushHistory(st, last);
          }
        }catch(e){ /* símbolo pode não existir em BRL na Binance */ }
        try{
          // best bid/ask
          const bt = await getJSON(ENDPOINTS_BINANCE.BOOK_TICKER(sym));
          const bid = Number(bt?.bidPrice ?? NaN);
          const ask = Number(bt?.askPrice ?? NaN);
          const st = S[pair];
          st.alt.bid = Number.isFinite(bid) ? bid : st.alt.bid;
          st.alt.ask = Number.isFinite(ask) ? ask : st.alt.ask;
          if(Number.isFinite(st.alt.bid) && Number.isFinite(st.alt.ask)) st.alt.at = Date.now();
        }catch(e){ /* ignorar se indisponível */ }
      }));
      await sleep(150);
    }
  }

  // ===== RENDER ==============================================================
  function render(){
    // fita/marquee
    tape.textContent = COINS.map(c => {
      const st = S[c.pair];
  const priceNum = choosePrice(st);
  const price = Number.isFinite(priceNum) ? fmtBRL.format(priceNum) : '—';
      const d = (st.prev && st.last) ? (st.last - st.prev) : 0;
      const s = d > 0 ? '▲' : d < 0 ? '▼' : '•';
      return `${c.symbol} ${price} ${s}`;
    }).join('  ·  ');

    // tiles
    for(const c of COINS){
      const k = c.pair, st = S[k];
  const dispPrice = choosePrice(st);
  setPrice(`p-${k}`, dispPrice);
      // delta curto vs tick anterior
      let deltaStr = '—', cls = '';
      if(Number.isFinite(st.last) && Number.isFinite(st.prev)){
        const delta = st.last - st.prev;
        const perc = st.prev ? (delta/st.prev*100) : 0;
        deltaStr = `${delta>=0?'+':''}${perc.toFixed(2)}%`;
        cls = delta>0 ? 'up' : delta<0 ? 'down' : '';
      }
      setDelta(`d-${k}`, deltaStr, cls);

      setText(`hi-${k}`, Number.isFinite(st.high) ? fmtBRL.format(st.high) : '—');
      setText(`lo-${k}`, Number.isFinite(st.low)  ? fmtBRL.format(st.low)  : '—');
      setText(`vo-${k}`, Number.isFinite(st.vol)  ? fmtNum.format(st.vol)  : '—');

  const bidDisp = Number.isFinite(st.bid) ? st.bid : (Number.isFinite(st.alt.bid) ? st.alt.bid : null);
  const askDisp = Number.isFinite(st.ask) ? st.ask : (Number.isFinite(st.alt.ask) ? st.alt.ask : null);
  const sprDisp = (Number.isFinite(bidDisp) && Number.isFinite(askDisp)) ? (askDisp - bidDisp) : (Number.isFinite(st.spread) ? st.spread : null);
  setText(`bid-${k}`, Number.isFinite(bidDisp) ? fmtBRL.format(bidDisp) : '—');
  setText(`ask-${k}`, Number.isFinite(askDisp) ? fmtBRL.format(askDisp) : '—');
  setText(`spu-${k}`, Number.isFinite(sprDisp) ? fmtBRL.format(sprDisp) : '—');

      const tr = st.trade;
      const side = (tr?.type || tr?.TYPE || '').toString().toUpperCase();
      const sideClass = side === 'BUY' ? 'buy' : side === 'SELL' ? 'sell' : '';
      setPill(`tt-${k}`, side || '—', sideClass);
      setText(`ta-${k}`, tr?.amount != null ? `${fmtNum.format(Number(tr.amount))}` : '—');
      setText(`tp-${k}`, tr?.price  != null ? fmtBRL.format(Number(tr.price)) : '—');
      setText(`ts-${k}`, tr?.timestamp ? humanTime(tr.timestamp) : '—');

      drawSpark(`sp-${k}`, st.history);
    }
  }

  // Define preço com fallback de compactação e ajuste iterativo de fonte
  function setPrice(id, value){
    const el = document.getElementById(id); if(!el) return;
    const parent = el.parentElement; if(!parent){ el.textContent = '—'; return; }
    if(!Number.isFinite(value)){ el.textContent = '—'; return; }
    // reset estilo e tenta com formato normal
    el.style.fontSize = '';
    el.textContent = fmtBRL.format(value);
    compactToFit(el, parent, value);
  }

  function compactToFit(el, parent, value){
    const maxW = parent.clientWidth - 4;
    if(el.scrollWidth <= maxW) return; // já cabe
    // 1) reduzir fonte gradualmente até limite
    let style = getComputedStyle(el);
    let fs = parseFloat(style.fontSize) || 32;
    let steps = 0;
    while(el.scrollWidth > maxW && fs > 14 && steps < 6){
      fs = Math.max(14, Math.floor(fs * 0.9));
      el.style.fontSize = fs + 'px';
      steps++;
    }
    if(el.scrollWidth <= maxW) return;
    // 2) usar notação compacta de moeda (K/M/B) preservando BRL
    const c = Math.abs(value);
    let short;
    if(c >= 1_000_000_000){ short = 'R$ ' + (value/1_000_000_000).toFixed(2).replace('.',',') + ' bi'; }
    else if(c >= 1_000_000){ short = 'R$ ' + (value/1_000_000).toFixed(2).replace('.',',') + ' mi'; }
    else if(c >= 1_000){ short = 'R$ ' + (value/1_000).toFixed(2).replace('.',',') + ' mil'; }
    else { short = fmtBRL.format(value); }
    el.textContent = short;
    // tenta reduzir um pouco mais se necessário
    style = getComputedStyle(el);
    fs = parseFloat(style.fontSize) || 16;
    steps = 0;
    while(el.scrollWidth > maxW && fs > 12 && steps < 3){
      fs = Math.max(12, Math.floor(fs * 0.95));
      el.style.fontSize = fs + 'px';
      steps++;
    }
  }

  function choosePrice(st){
    const now = Date.now();
    const freshMs = 2 * REFRESH_MS;
    if(Number.isFinite(st.last) && st.lastAt && (now - st.lastAt) < freshMs) return st.last;
    if(Number.isFinite(st.alt.last) && st.alt.at && (now - st.alt.at) < freshMs) return st.alt.last;
    return Number.isFinite(st.last) ? st.last : (Number.isFinite(st.alt.last) ? st.alt.last : NaN);
  }

  function setText(id, txt){ const el = document.getElementById(id); if(el) el.textContent = txt; }
  function setDelta(id, txt, cls){ const el = document.getElementById(id); if(!el) return; el.textContent=txt; el.className = `delta ${cls}`; }
  function setPill(id, txt, cls){ const el = document.getElementById(id); if(!el) return; el.textContent = txt; el.className = `pill ${cls}`; }

  function humanTime(ts){
    const t = new Date(ts);
    if(isNaN(+t)) return String(ts);
    const diff = (Date.now()-t.getTime())/1000; // s
    if(diff < 60) return `${Math.floor(diff)}s atrás`;
    if(diff < 3600) return `${Math.floor(diff/60)}min atrás`;
    const d = t.toLocaleTimeString('pt-BR',{hour:'2-digit',minute:'2-digit'});
    return d;
  }

  function drawSpark(id, series){
    const el = document.getElementById(id); if(!el) return;
    const ctx = el.getContext('2d');
    const w = el.width, h = el.height;
    // HiDPI fix
    const dpr = window.devicePixelRatio || 1;
    if(el._dpr !== dpr){ el._dpr = dpr; el.width = Math.floor(el.clientWidth*dpr); el.height = Math.floor(el.clientHeight*dpr); }
    const W = el.width, H = el.height;

    ctx.clearRect(0,0,W,H);
    // background grid-ish
    ctx.globalAlpha = .5; ctx.strokeStyle = 'rgba(255,255,255,.04)';
    const lines = 3; for(let i=1;i<=lines;i++){ const y = (H/(lines+1))*i; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    ctx.globalAlpha = 1;

    if(!series || series.length<2){ return; }
    const min = Math.min(...series), max = Math.max(...series);
    const pad = 6*dpr;
    const scaleX = (i)=> pad + (W-2*pad) * (i/(series.length-1));
    const scaleY = (v)=>{
      if(max===min) return H/2; // flat
      return H - pad - ( (v - min) / (max - min) ) * (H - 2*pad);
    };
    // line
    const last = series[series.length-1], prev = series[series.length-2];
    const up = last >= prev;
    ctx.lineWidth = 2*dpr;
    ctx.strokeStyle = up ? 'rgba(0,200,83,.95)' : 'rgba(255,59,48,.95)';
    ctx.beginPath();
    ctx.moveTo(scaleX(0), scaleY(series[0]));
    for(let i=1;i<series.length;i++) ctx.lineTo(scaleX(i), scaleY(series[i]));
    ctx.stroke();
    // gradient fill
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, up ? 'rgba(0,200,83,.20)' : 'rgba(255,59,48,.20)');
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.lineTo(W-pad, H-pad); ctx.lineTo(pad, H-pad); ctx.closePath(); ctx.fill();
  }

  // ===== LOOP ================================================================
  async function cycle(){
    await fetchTickers();
    await fetchOrderbookAndTrades();
    render();
    lastUpdate.textContent = new Date().toLocaleTimeString('pt-BR', {hour:'2-digit', minute:'2-digit', second:'2-digit'});
  cycleCount++;
  }

  // ===== SCHEDULER: evita sobreposição e ajusta conforme visibilidade =======
  let _cycleTimer = null;
  let _isRunning = false;
  function nextDelay(){ return document.hidden ? REFRESH_HIDDEN_MS : REFRESH_MS; }
  function scheduleNext(ms){ if(_cycleTimer) clearTimeout(_cycleTimer); _cycleTimer = setTimeout(runCycle, ms); }
  async function runCycle(){
    if(_isRunning){ scheduleNext(250); return; }
    _isRunning = true;
    try{ await cycle(); }
    catch(e){ console.error('cycle erro:', e); }
    finally{
      try{
        // alterna atualizações leves da Binance entre ciclos
        if((cycleCount % 2) === 1){ await fetchBinanceLight(); render(); }
      }catch(e){ console.error('binance erro:', e); }
      _isRunning = false; scheduleNext(nextDelay());
    }
  }
  // kick
  runCycle();
  document.addEventListener('visibilitychange', () => {
    // Recalcular frequência de trades quando voltar a ficar visível
    if(!document.hidden){ FETCH_TRADES_EVERY = computeTradesEvery(REFRESH_MS); }
    scheduleNext(250);
  });

  // ===== FULLSCREEN ==========================================================
  const fsBtn = document.getElementById('fullscreenBtn');
  fsBtn.addEventListener('click', toggleFS);
  document.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='f') toggleFS(); });
  function toggleFS(){
    const el = document.documentElement;
    if(!document.fullscreenElement){
      (el.requestFullscreen && el.requestFullscreen()) ||
      (el.webkitRequestFullscreen && el.webkitRequestFullscreen());
    } else {
      (document.exitFullscreen && document.exitFullscreen()) ||
      (document.webkitExitFullscreen && document.webkitExitFullscreen());
    }
  }

  // ===== RESIZE SPARKLINES ON LAYOUT CHANGES ================================
  const ro = new ResizeObserver(()=> render());
  ro.observe(grid);
})();
</script>

<!--
Referências de API (BitPreço):
- Ticker (moeda):    https://api.bitpreco.com/btc-brl/ticker
- Ticker (todas):    https://api.bitpreco.com/all-brl/ticker
- Orderbook (moeda): https://api.bitpreco.com/btc-brl/orderbook
- Trades (moeda):    https://api.bitpreco.com/btc-brl/trades

Limite de taxa (doc BitPreço): até 30 acessos/min somando API pública e de negociações.

Observações:
- Se algum par não existir (ex.: BNB-BRL indisponível), o card exibirá "—".
- Este arquivo é "single-file" (HTML, CSS e JS inline). Hospede em qualquer servidor estático
  (GitHub Pages, DigitalOcean, etc.)
- Para alterar moedas/intervalo, ajuste o array COINS e REFRESH_MS no topo do script.
-->
</body>
</html>
